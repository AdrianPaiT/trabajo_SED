library ieee;
use IEEE.STD_LOGIC_1164.ALL;

entity fsm is 
port ( 
    RESET      : in  std_logic; 
    CLK        : in  std_logic; 
    BUTTON     : in  std_logic_vector(0 to 4);  -- Botones de 0 a 4
    seg7_1     : out std_logic_vector(6 downto 0);  -- Display 1 (más a la izquierda)
    seg7_2     : out std_logic_vector(6 downto 0);  -- Display 2
    seg7_3     : out std_logic_vector(6 downto 0);  -- Display 3
    seg7_4     : out std_logic_vector(6 downto 0);  -- Display 4
    seg7_5     : out std_logic_vector(6 downto 0);  -- Display 5 (más a la derecha)
    led_result : out std_logic  -- LED de resultado (correcto o incorrecto)
); 
end fsm; 

architecture behavioral of fsm is 
    -- Definición de los estados
    type STATES is (S0, S1, S2, S3, S4, DONE);  
    signal current_state: STATES := S0; 
    signal next_state: STATES; 
    signal password : std_logic_vector(4 downto 0) := "00000";  -- Secuencia ingresada por el usuario
    constant correct_password : std_logic_vector(4 downto 0) := "01011";  -- Contraseña correcta (3-2-4-5-1)

    -- Función para convertir un bit ('0' o '1') a su patrón de 7 segmentos
    function to_seven_seg (num : std_logic) return std_logic_vector is
    begin
        if num = '0' then
            return "1111110";  -- Representación del número 0
        else
            return "0110000";  -- Representación del número 1
        end if;
    end function;

begin 

    -- Registro de estados (flip-flop)
    process (RESET, CLK)
    begin
        if RESET = '1' then
            current_state <= S0;  -- Resetear al estado S0
        elsif rising_edge(CLK) then
            current_state <= next_state;  -- Avanzar al siguiente estado
        end if;
    end process; 

    -- Lógica de transición de estados
    process (current_state, BUTTON)
    begin 
        next_state <= current_state;  -- Inicializar el siguiente estado como el actual

        case current_state is 
            when S0 => 
                if BUTTON(0) = '1' then 
                    password(0) <= '1';  
                end if;
                next_state <= S1;

            when S1 => 
                if BUTTON(1) = '1' then 
                    password(1) <= '1';  
                end if;
                next_state <= S2;

            when S2 => 
                if BUTTON(2) = '1' then 
                    password(2) <= '1';  
                end if;
                next_state <= S3;

            when S3 => 
                if BUTTON(3) = '1' then 
                    password(3) <= '1';  
                end if;
                next_state <= S4;

            when S4 => 
                if BUTTON(4) = '1' then 
                    password(4) <= '1';  
                end if;
                next_state <= DONE;

            when DONE =>
                -- Comparar la contraseña ingresada con la correcta
                if password = correct_password then
                    led_result <= '1';  -- Contraseña correcta, encender LED de éxito
                else
                    led_result <= '0';  -- Contraseña incorrecta, apagar LED de éxito
                end if;
                next_state <= S0;  -- Volver al estado inicial para un nuevo intento
        end case; 
    end process; 

    -- Lógica para los displays de 7 segmentos
    process (password)
    begin
        -- Convertir cada bit ingresado a su patrón correspondiente en los displays de 7 segmentos
        seg7_1 <= to_seven_seg(password(0));  -- Primer dígito en el display más a la izquierda
        seg7_2 <= to_seven_seg(password(1));  -- Segundo dígito
        seg7_3 <= to_seven_seg(password(2));  -- Tercer dígito
        seg7_4 <= to_seven_seg(password(3));  -- Cuarto dígito
        seg7_5 <= to_seven_seg(password(4));  -- Quinto dígito en el display más a la derecha
    end process;

end behavioral;
